#include <bits/stdc++.h>
using namespace std;
 
int main() {
 
	int N, Q;
	string S;
	cin >> N >> S >> Q;

	int T, A, B = 0;
    int Flag_reverted = 0;  // 反転されているかどうか

	for (int i = 0; i < Q; i++) {
		cin >> T >> A >> B;
		if (T == 2){
			Flag_reverted ^= 1; //排他的論理和．1と0を反転させる.
			continue;
		}

        // Flag_reverted = 0 (反転されていなければ), A, B = A - 1, B - 1
        // A, B > N のときも、配列の枠を飛び越えて右にズラすイメージ。その後、剰余をとって、帳尻を合わせる。
		A = (A - 1 + N * Flag_reverted) % (2 * N);  
		B = (B - 1 + N * Flag_reverted) % (2 * N);

		swap(S[A],S[B]);  // ２つのオブジェクトの値を入れ替えるテンプレート関数
	}

    // 初期化
	string s1 = "", s2 = "";

    s1 = S.substr(0, N);
    s2 = S.substr(N);

    // 反転されていなければそのまま出力
	if (Flag_reverted == 0) {
        cout << S << endl;  
    } else {
        cout << s2 << s1 << endl;  // s1とs2を反転させる
    }
 
} 

/* 公式解説
クエリを問題文の通りに処理すると、(例えば全て T_i = 2 の場合に) 計算量が \Theta(QN) となってしまい実行時間制限に間に合いません。<br>
そのため、T_i = 2 の場合を高速に処理しなければなりません。
今前半 N 文字と後半 N 文字が反転されているかを表す変数 t を持っておきます。(最初 t は偽です)
T_i = 2 のクエリのときは t の真偽を反転するだけで済みます。
T_i = 1 のクエリのとき、t が偽ならそのまま A_i 文字目と B_i 文字目を入れ替えればよいです。
t が真のとき、データ上の S は実際の S と比べて前半 N 文字と後半 N 文字が反転されています。実際の S のx 文字目は、x \le N のときデータ上の S では x + N 文字目に対応し、x \gt N のときはデータ上の S の x - N 文字目に対応します。<br>
よって、A_i, B_i をこのように変換してからデータ上の S で文字の交換を行えばよいです。

全てのクエリを処理し終わった後、最後に t が真なら S の前半 N 文字と後半 N 文字を反転してから出力し、偽なら S をそのまま出力すればよいです。<br>
この解法の計算量は O(N + Q) となるので、実行時間制限にも十分間に合います。
*/