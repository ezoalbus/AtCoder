#include <bits/stdc++.h>
using namespace std;

/* 解法メモ
排他的論理和をとる演算を∧で表すと，次の2つが成り立つ。
1. ∀n \in 自然数, n ∧ n = 0
2. ∀n \in 偶数, n ∧ (n+1) = 1
(∵ (2.) 偶数nについて, 
nとn+1を2進数表記したときに最下位ビットのみが異なるから)

用いる事実:
3. f(A, B) = F(0, A-1) ∧ F(0, B)
(∵ 
    F(A, B) = F(0, A - 1 F(0, A - 1) ∧ F(A, B) \\
    = F(0, A - 1) ∧ 0 ∧ 1 ∧ ... ∧ (A - 1) ∧ A ∧ ... ∧ B \\
    = F(0, A - 1) ∧ F(0, B)
)

4. f(0, X) = 0 ∧ 1 ∧ 2 ∧ 3 ∧ 4 ∧ 5 ∧ ... ∧ X \\
           = (0 ∧ 1) ∧ (2 ∧ 3) ∧ (4 ∧ 5) ∧ ... ∧ X \\
           = 1 ∧ 1 ∧ 1 ∧ ... ∧ X (Xが奇数の場合はX-1∧X=1よりXが消える)
*/

// f(0, x) を計算する
long long f(long long x) {
    long long res = 0;
    // x が偶数
    if (x % 2 == 0) {
        res = x;  // 自分が残る
    // } else { // x が奇数
    //     // 隣り合って1になるペアの数
    //     long long num_1 = (x - 1) / 2;
    //     // 1が偶数個あれば全体で0
    //     if (num_1 % 2 == 0) {
    //         res = 1; // 0 ^ 1
    //     } else {
    //         // resは0で初期化しているのでなくて良い
    //         res = 0; // 1 ^ 1
    //     }
        // シリアルにifを繋げないといけない
        // xが偶数でも，1∧1∧x と 1∧xのどちらもありうる
        if (x % 4 != 0) { // (x+1)/2は，(x-1)∧x=1も含めた1の総数
            res ^= 1; // 1が奇数個
            // 0と排他的論理和をとっても変わらない(000 ∧ 101)
        }
    // x が奇数
    } else { 
        if ((x + 1) % 4 != 0) {
            res ^= 1;
        }
    }
    return res;
}

int main() {
    long long A, B;
    cin >> A >> B;
    // cin >> A;
    cout << (f(A - 1) ^ f(B)) << endl;
    // cout << f(A) << endl;
}
